### 数组

* 有序二维数组查找
	* 题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
	* 题目思路：矩阵是有序的，从左下角来看，向上数字递减，向右数字递增。因此从左下角开始查找，当要查找数字比左下角数字大时，右移。要查找数字比左下角数字小时，上移。（同理可从右上角查）


### 字符串

* 替换空格
	* 题目描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
	* 题目思路：首先遍历一遍字符串，统计出空格的个数，并由此能够计算出替换之后的字符串的长度。同时设置两个指针P1和P2，P1指向原始字符串末尾，P2指向替换之后的字符串末尾。我们向前移动P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。然后把P1向前移动一格，在P2之前插入字符串“%20”，同时P2向前移动3格。




### 链表

* 从尾到头打印链表
	* 使用栈辅助，后进先出 
* 打印链表倒数第k个节点（即距离尾节点k-1步）
	* 使用两个指针，第一个先向前移动k-1步,第二个指向头结点
	* 然后两个同时移动，当第一个指针指向尾节点时，第二个指针指向的即为倒数第k个节点
	* 需要注意鲁棒性，比如判断链表头结点是否为空，链表





### 树
* 根据树的前序遍历和中序遍历，重建二叉树。

	```
	let pre = [1,2,4,7,3,5,6,8]
	let mid = [4,7,2,1,5,3,8,6]
	```

	解法：
	* 使用前序找到根节点(即pre[0])。
	* 在中序遍历中，查找根节点索引(index)，根节点左侧即为左子树，右侧即为右子树。左子树的中序遍历，即为(0..<index)的子串。右子树同理为(index+1..<count)
	* 前序遍历中。pre[0]为根节点，左子树的长度为index。所以左子树的前序遍历即为 (1..<index+1)的子串。右子树为(index+1..<count)的子串。
	* 拿到了左右子树的前序遍历和中序遍历，递归左右子树，重复上面的调用。具体见代码<BuildTree.swift>




### 栈和队列

* 使用两个栈实现队列
	* 解法：添加操作，即入队操作，向**stack1**做压栈操作即可。
	* 删除操作，即出队操作，将**stack1**中的数据全部出栈，依次压入**stack2**，然后**stack2**把栈顶元素弹出即可。
	* 后续入队出队操作，入队继续向**stack1**做压栈操作即可。出队判断**stack2**是否为空，不为空直接出栈；为空将**stack1**中的数据全部出栈，依次压入**stack2**，然后**stack2**把栈顶元素弹出即可。
* 使用两个队列实现栈
	* 解法：添加操作，即压栈操作。检测两个队列那个非空，向非空的队列入队即可。
	* 删除操作，即出栈。将非空队列(queue1)，出队n-1个元素，入队空队列(queue2)。最后queue1剩余的一个元素，出队后返回即可。
	* 后续入栈出栈操作，入栈向非空队列添加元素。出栈同上。




### 查找和排序

* 旋转数组的最小数字（从小到大）
	* 题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。(注意数字有可能会重复，eg:{ 3, 4, 5, 1, 1, 2 ,3 ,3 ,3 ,3};)
	* 题目思路:
		2. 如果左右两侧数不等，即左侧数>右侧，使用二分法，查找中间数和左右两侧的值比大小。
		3. 如果中间数大于等于左侧数，说明最小数在右侧子序列，继续二分查找右侧序列。
		4. 如果中间数小于等于左侧数，说明最小数在左侧子序列，继续二分查找左侧序列。
		1. 如果左中右三个数相等，此时只能按照顺序查找。（从当前子串的左遍历到右查找最小值）

	
	
### 递归和循环

* 斐波那契数列，见代码。
* 青蛙上楼问题，青蛙一次能跳1个或者2个台阶，问跳到第n个台阶有多少种跳发。
	* 设跳n个台阶有f(n)种跳法。
	* 如果青蛙先跳了1个台阶，则剩下n-1个台阶就还有**f(n-1)**种跳法
	* 如果青蛙先跳了2个台阶，则剩下n-2个台阶就还有**f(n-2)**种跳法
	* 所以跳上n个台阶的跳法总共有**f(n-1)**+**f(n-2)**种，即斐波那契数列。

	
	
	
### 位运算

* 计算一个数中的二进制里1的个数。
	* 这里只考虑正数，不考虑补码。 (n & (n-1))相当于将 二进制下的 最右侧的第一个1置为0。见下面代码：  

```
func numb(_ n:Int) -> Int {
    var n = n
    var count = 0
    while n != 0 {
        n = n & (n-1)
        count += 1
    }
    return count
}
```



