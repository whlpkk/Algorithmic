### 数组

* 有序二位数组查找
    * 从右上或者左下开始，一列列排除



### 字符串

* 替换空格
    * 从后向前存储，避免移动多次



### 链表

* 从尾到头打印链表
	* 使用辅助堆栈，后进先出 
* 打印链表倒数第k个节点（即距离尾节点k-1步）
	* 使用两个指针，第一个先向前移动k-1步,第二个指向头结点
	* 然后两个同时移动，当第一个指针指向尾节点时，第二个指针指向的即为倒数第k个节点
	* 需要注意鲁棒性，比如判断链表头结点是否为空，链表





### 树

* 根据数的前序遍历和中序遍历，重建二叉树。
	* 解法：使用前序找到根节点。
	* 在中序遍历中找出左子树和右子树的。
	* 在前序遍历中找出左右子树。
	* 递归左右子树，重复上面的调用。具体见代码<BuildTree.swift>




### 栈和队列

* 使用两个栈实现队列
	* 解法：添加操作，即入队操作，向**stack1**做压栈操作即可。
	* 删除操作，即出队操作，将**stack1**中的数据全部出栈，依次压入**stack2**，然后**stack2**把栈顶元素弹出即可。
* 使用两个队列实现栈
	* 解法：添加操作，即压栈操作，检测两个队列




### 查找和排序

* 旋转数组的最小数字（从小到大）
	* 如果左右两侧数相等，此时只能按照顺序查找。
	* 如果左右两侧数不等，即左侧数>右侧，使用二分法，查找中间数和左右两侧的值比大小。
	* 如果中间数大于等于左侧数，说明最小数在右侧子序列，继续二分查找右侧序列。
	* 如果中间数小于等于左侧数，说明最小数在右侧子序列，继续二分查找右侧序列。

	
	
### 递归和循环

* 斐波那契数列，见代码。
* 青蛙上楼问题，青蛙一次能跳1个或者2个台阶，问跳到第n个台阶有多少种跳发。
	* 设跳n个台阶有f(n)种跳法。
	* 如果青蛙先跳了1个台阶，则剩下n-1个台阶就还有**f(n-1)**种跳法
	* 如果青蛙先跳了2个台阶，则剩下n-2个台阶就还有**f(n-2)**种跳法
	* 所以跳上n个台阶的跳法总共有**f(n-1)**+**f(n-2)**种，即斐波那契数列。

	
	
	
### 位运算

* 计算一个数中的二进制里1的个数。
	* 这里只考虑正数，不考虑补码。 (n & (n-1))相当于将 二进制下的 最右侧的第一个1置为0。见下面代码：  

```
func numb(_ n:Int) -> Int {
    var n = n
    var count = 0
    while n != 0 {
        n = n & (n-1)
        count += 1
    }
    return count
}
```



